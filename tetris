#!/usr/bin/env ruby

require 'gosu'
require 'texplay'

# TODO handling peice overlaping the border of the board

Coord = Struct.new(:x,:y)

class Coord

  def dup
    Coord.new(self.x,self.y)
  end

end

class GameWindow < Gosu::Window
  
  BLOCK_WIDTH = 20

  BOARD_WIDTH = 8
  BOARD_HEIGHT = 20

  WINDOW_WIDTH=BOARD_WIDTH * BLOCK_WIDTH
  WINDOW_HEIGHT = BOARD_HEIGHT * BLOCK_WIDTH

  def initialize
    super WINDOW_WIDTH, WINDOW_HEIGHT, false
    self.caption = "Tetris"


    @board = Board.new(BOARD_WIDTH,BOARD_HEIGHT)
    @peice = TetronGenerator.from_random
    @position = Coord.new(0,0)
    
  end

  LOGIC_DELAY = 0.5 # seconds

  def time_for_logic?
    now = Time.now
    if @last_logic_time
      now - @last_logic_time > LOGIC_DELAY
    else
      @last_logic_time = now
    end
  end

  def logic_update
    @last_logic_time = Time.now

    @position.y += 1

    # TODO if lowest cell of peice is at the bottom on the screen.
    if @position.y >= BOARD_HEIGHT
      apply_peice
      puts "peice passed off end of board"
    end

  end

  INPUT_DELAY = 0.1

  def time_for_input?
    now = Time.now
    if @last_input_time
      now - @last_input_time > INPUT_DELAY
    else
      @last_input_time = now
    end
  end

  def input_update
    @last_input_time = Time.now

    if button_down? Gosu::KbLeft or button_down? Gosu::GpLeft
      @position.x -= 1
    elsif  button_down? Gosu::KbRight or button_down? Gosu::GpRight
      @position.x += 1
    end

    @position.x = 0 if @position.x < 0
    @position.x = 8 if @position.x > 8


    if @peice.collides_with?(@board, @position)
      puts "peice collided with other peice"
      apply_peice
    end

    if button_down? Gosu::KbUp or button_down? Gosu::GpUp
      @peice.rotate
    end

    puts "now: #{Time.now} position: #{@position}"

  end

  def apply_peice
    @board.merge!(@peice, @position)
    @peice = TetronGenerator.from_random
    @position = Coord.new(0,0)
  end

  def update

    if time_for_input?
      input_update
    end
    

    if time_for_logic?
      logic_update
    end

  end
  
  def button_down(id)
    if button_down? Gosu::KbDown or button_down? Gosu::GpDown
      logic_update
    end
    if id == Gosu::KbEscape
      close
    end
  end
  
  def grid_to_screen(x,y)
    Coord.new(x * BLOCK_WIDTH,y * BLOCK_WIDTH)
  end
  
  def draw
    unless @background
      @background = TexPlay::create_blank_image($window, WINDOW_WIDTH, WINDOW_HEIGHT)
      @background.rect 0,0,WINDOW_WIDTH,WINDOW_HEIGHT, :color => :black, :fill => true
    end

    @background.draw(0,0,1)
    @board.draw(Coord.new(0,0))
    @peice.draw(@position)

    flush
  end

end

class Grid

  # A grid of true/false values that represents a peice or the board

  attr_reader :grid, :width, :height

  def initialize(width,height)
    @width = width
    @height = height
    @grid = []
    (0..@width - 1).each do |x|
      @grid[x] = []
      (0..@height - 1).each do |y|
        @grid[x][y] = false
      end
    end
  end

  def each_cell
    (0..@width - 1).each do |x|
      (0..@height - 1).each do |y|
        yield x, y, self.grid[x][y]
      end
    end
  end

  def merge!(other,origin)
    other.each_cell do |other_x, other_y, other_value|
      self.grid[origin.x + other_x][origin.y + other_y] = true if other_value
    end

  end

  def overlaps_with?(other,origin)
    # does it ly within the bounds of this other grid?

    if origin.x <0 or origin.y < 0
      return false
    end

    if origin.x + other.width > self.width or origin.y + other.height > self.height
      return false
    end

    return true

  end

  def collides_with?(other,origin)
    collided = false
    other.each_cell do |other_x,other_y,other_value|
      local_x = origin.x + other_x
      local_y = origin.y + other_y
      if local_x < self.width and local_y < self.height and other_value and self.grid[local_x][local_y]
        puts "collision at #{[local_x,local_y]}"
        collided = true
      end
    end
    collided
  end

  def self.grid_to_screen(grid_position)
    Coord.new(grid_position.x * GameWindow::BLOCK_WIDTH, grid_position.y * GameWindow::BLOCK_WIDTH)
  end

  def draw(grid_position)
    unless @block
      puts "create block for render"
      @block = TexPlay::create_blank_image($window, GameWindow::BLOCK_WIDTH, GameWindow::BLOCK_WIDTH)
      @block.rect 0,0,GameWindow::BLOCK_WIDTH,GameWindow::BLOCK_WIDTH, :color => :red, :fill => true
    end

    self.each_cell do |cell_x,cell_y,value|
      if value
        position = Grid.grid_to_screen(Coord.new(grid_position.x + cell_x,grid_position.y + cell_y))
        @block.draw(position.x, position.y, 1)
      end
    end
  end

  def rotate
    # unimplemented
  end

end

class Board < Grid

end

class Tetron < Grid

  def initialize
    super(2,4)
  end

end


class TetronGenerator

  STRAIGHT = Tetron.new
  STRAIGHT.grid[0][0] = true
  STRAIGHT.grid[0][1] = true
  STRAIGHT.grid[0][2] = true
  STRAIGHT.grid[0][3] = true

  DOT = Tetron.new
  DOT.grid[0][0] = true

  TETRONS = [STRAIGHT,DOT]

  def self.from_random
    TETRONS.sample
  end

end

$window = GameWindow.new
$window.show




